const mongoose = require('mongoose');
const logger = require('../src/utils/logger');
const { analyzeUnusedFields } = require('./analyze-unused-fields');
const { migrateDuplicatedFields } = require('./migrate-duplicated-fields');
const { cleanupObsoleteFields } = require('./cleanup-obsolete-fields');
require('dotenv').config();

/**
 * Script maestro para optimizaci√≥n completa de MongoDB
 * Ejecuta an√°lisis, migraci√≥n y limpieza en el orden correcto
 */

const OPTIMIZATION_PHASES = {
  ANALYSIS: 'analysis',
  MIGRATION: 'migration',
  CLEANUP: 'cleanup',
  VALIDATION: 'validation'
};

/**
 * Configuraci√≥n de optimizaci√≥n
 */
const OPTIMIZATION_CONFIG = {
  // Fases a ejecutar (se pueden deshabilitar individualmente)
  phases: {
    analysis: true,
    migration: true,
    cleanup: true,
    validation: true
  },
  
  // Configuraci√≥n de seguridad
  safety: {
    createBackups: true,
    requireConfirmation: false, // Cambiar a true en producci√≥n
    maxDocumentsToProcess: 10000, // L√≠mite de seguridad
    dryRun: false // Solo simular sin hacer cambios
  },
  
  // Configuraci√≥n de rendimiento
  performance: {
    batchSize: 100,
    maxConcurrency: 5,
    progressInterval: 100
  }
};

/**
 * Verificar prerrequisitos del sistema
 */
async function checkPrerequisites() {
  try {
    logger.info('üîç Verificando prerrequisitos del sistema...');
    
    const checks = {
      mongodb: false,
      diskSpace: false,
      permissions: false,
      backupDir: false
    };
    
    // Verificar conexi√≥n a MongoDB
    try {
      await mongoose.connect(process.env.MONGODB_URI);
      checks.mongodb = true;
      logger.success('‚úÖ Conexi√≥n a MongoDB exitosa');
    } catch (error) {
      logger.error('‚ùå Error conectando a MongoDB:', error.message);
      return { checks, passed: false };
    }
    
    // Verificar espacio en disco
    const fs = require('fs');
    const path = require('path');
    
    try {
      const stats = fs.statSync(path.join(__dirname, '..'));
      checks.diskSpace = true;
      logger.success('‚úÖ Acceso al sistema de archivos verificado');
    } catch (error) {
      logger.error('‚ùå Error verificando espacio en disco:', error.message);
    }
    
    // Verificar permisos de escritura
    try {
      const testFile = path.join(__dirname, '../test-permissions.tmp');
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);
      checks.permissions = true;
      logger.success('‚úÖ Permisos de escritura verificados');
    } catch (error) {
      logger.error('‚ùå Error verificando permisos:', error.message);
    }
    
    // Verificar/crear directorio de backups
    try {
      const backupDir = path.join(__dirname, '../backups');
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }
      checks.backupDir = true;
      logger.success('‚úÖ Directorio de backups verificado');
    } catch (error) {
      logger.error('‚ùå Error con directorio de backups:', error.message);
    }
    
    const passed = Object.values(checks).every(check => check);
    
    if (passed) {
      logger.success('üéâ Todos los prerrequisitos cumplidos');
    } else {
      logger.error('‚ùå Algunos prerrequisitos no se cumplen');
    }
    
    return { checks, passed };
  } catch (error) {
    logger.error('‚ùå Error verificando prerrequisitos:', error);
    throw error;
  }
}

/**
 * Estimar tiempo y recursos necesarios
 */
async function estimateResources() {
  try {
    logger.info('üìä Estimando recursos necesarios...');
    
    const User = require('../src/models/User');
    const Transaction = require('../src/models/Transaction.model');
    const Commission = require('../src/models/Commission.model');
    const Package = require('../src/models/Package.model');
    const UserStatus = require('../src/models/UserStatus');
    
    const counts = {
      users: await User.countDocuments(),
      transactions: await Transaction.countDocuments(),
      commissions: await Commission.countDocuments(),
      packages: await Package.countDocuments(),
      userStatuses: await UserStatus.countDocuments()
    };
    
    const totalDocuments = Object.values(counts).reduce((sum, count) => sum + count, 0);
    
    // Estimaciones basadas en experiencia
    const estimates = {
      totalDocuments,
      estimatedTime: {
        analysis: Math.ceil(totalDocuments / 1000) * 2, // 2 min por cada 1000 docs
        migration: Math.ceil(counts.users / 100) * 1, // 1 min por cada 100 usuarios
        cleanup: Math.ceil(totalDocuments / 500) * 1, // 1 min por cada 500 docs
        validation: Math.ceil(totalDocuments / 2000) * 1 // 1 min por cada 2000 docs
      },
      estimatedSpace: {
        backups: Math.ceil(totalDocuments / 100) * 10, // 10MB por cada 100 docs
        reports: 5, // 5MB para reportes
        temporary: Math.ceil(totalDocuments / 1000) * 50 // 50MB por cada 1000 docs
      },
      collections: counts
    };
    
    estimates.estimatedTime.total = Object.values(estimates.estimatedTime).reduce((sum, time) => sum + time, 0);
    estimates.estimatedSpace.total = Object.values(estimates.estimatedSpace).reduce((sum, space) => sum + space, 0);
    
    logger.info('üìä Estimaciones de recursos:');
    console.table({
      'Documentos totales': totalDocuments.toLocaleString(),
      'Tiempo estimado (min)': estimates.estimatedTime.total,
      'Espacio estimado (MB)': estimates.estimatedSpace.total
    });
    
    return estimates;
  } catch (error) {
    logger.error('‚ùå Error estimando recursos:', error);
    throw error;
  }
}

/**
 * Ejecutar fase de an√°lisis
 */
async function executeAnalysisPhase() {
  try {
    logger.info('üîç FASE 1: AN√ÅLISIS DE CAMPOS NO UTILIZADOS');
    console.log('=' .repeat(60));
    
    if (OPTIMIZATION_CONFIG.safety.dryRun) {
      logger.info('üîÑ Modo DRY RUN - Solo simulaci√≥n');
    }
    
    // Ejecutar an√°lisis de campos no utilizados
    const analysisResult = await analyzeUnusedFields();
    
    logger.success('‚úÖ Fase de an√°lisis completada');
    return analysisResult;
  } catch (error) {
    logger.error('‚ùå Error en fase de an√°lisis:', error);
    throw error;
  }
}

/**
 * Ejecutar fase de migraci√≥n
 */
async function executeMigrationPhase() {
  try {
    logger.info('üîÑ FASE 2: MIGRACI√ìN DE CAMPOS DUPLICADOS');
    console.log('=' .repeat(60));
    
    if (OPTIMIZATION_CONFIG.safety.dryRun) {
      logger.info('üîÑ Modo DRY RUN - Solo simulaci√≥n');
      return { simulated: true };
    }
    
    // Ejecutar migraci√≥n de campos duplicados
    const migrationResult = await migrateDuplicatedFields();
    
    logger.success('‚úÖ Fase de migraci√≥n completada');
    return migrationResult;
  } catch (error) {
    logger.error('‚ùå Error en fase de migraci√≥n:', error);
    throw error;
  }
}

/**
 * Ejecutar fase de limpieza
 */
async function executeCleanupPhase() {
  try {
    logger.info('üßπ FASE 3: LIMPIEZA DE CAMPOS OBSOLETOS');
    console.log('=' .repeat(60));
    
    if (OPTIMIZATION_CONFIG.safety.dryRun) {
      logger.info('üîÑ Modo DRY RUN - Solo simulaci√≥n');
      return { simulated: true };
    }
    
    // Ejecutar limpieza de campos obsoletos
    const cleanupResult = await cleanupObsoleteFields();
    
    logger.success('‚úÖ Fase de limpieza completada');
    return cleanupResult;
  } catch (error) {
    logger.error('‚ùå Error en fase de limpieza:', error);
    throw error;
  }
}

/**
 * Ejecutar validaci√≥n final
 */
async function executeValidationPhase() {
  try {
    logger.info('üîç FASE 4: VALIDACI√ìN FINAL');
    console.log('=' .repeat(60));
    
    const User = require('../src/models/User');
    const Transaction = require('../src/models/Transaction.model');
    const Commission = require('../src/models/Commission.model');
    const Package = require('../src/models/Package.model');
    const UserStatus = require('../src/models/UserStatus');
    
    const validation = {
      collections: {
        users: await User.countDocuments(),
        transactions: await Transaction.countDocuments(),
        commissions: await Commission.countDocuments(),
        packages: await Package.countDocuments(),
        userStatuses: await UserStatus.countDocuments()
      },
      integrity: {
        usersWithStatus: 0,
        usersWithoutStatus: 0,
        orphanedStatuses: 0
      },
      performance: {
        indexesOptimized: 0,
        queriesImproved: 0
      }
    };
    
    // Verificar integridad de datos
    const usersWithStatus = await User.aggregate([
      {
        $lookup: {
          from: 'userstatuses',
          localField: '_id',
          foreignField: 'user',
          as: 'status'
        }
      },
      {
        $group: {
          _id: null,
          withStatus: {
            $sum: {
              $cond: [{ $gt: [{ $size: '$status' }, 0] }, 1, 0]
            }
          },
          withoutStatus: {
            $sum: {
              $cond: [{ $eq: [{ $size: '$status' }, 0] }, 1, 0]
            }
          }
        }
      }
    ]);
    
    if (usersWithStatus[0]) {
      validation.integrity.usersWithStatus = usersWithStatus[0].withStatus;
      validation.integrity.usersWithoutStatus = usersWithStatus[0].withoutStatus;
    }
    
    // Verificar UserStatus hu√©rfanos
    const orphanedStatuses = await UserStatus.aggregate([
      {
        $lookup: {
          from: 'users',
          localField: 'user',
          foreignField: '_id',
          as: 'userDoc'
        }
      },
      {
        $match: {
          'userDoc': { $size: 0 }
        }
      },
      {
        $count: 'count'
      }
    ]);
    
    validation.integrity.orphanedStatuses = orphanedStatuses[0]?.count || 0;
    
    logger.info('üìä Validaci√≥n final:');
    console.table(validation.collections);
    console.table(validation.integrity);
    
    const isValid = 
      validation.integrity.usersWithoutStatus === 0 &&
      validation.integrity.orphanedStatuses === 0;
    
    if (isValid) {
      logger.success('‚úÖ Validaci√≥n final exitosa');
    } else {
      logger.warn('‚ö†Ô∏è Se encontraron problemas en la validaci√≥n final');
    }
    
    return { validation, isValid };
  } catch (error) {
    logger.error('‚ùå Error en validaci√≥n final:', error);
    throw error;
  }
}

/**
 * Generar reporte final de optimizaci√≥n
 */
function generateFinalReport(startTime, estimates, results) {
  const endTime = new Date();
  const duration = Math.ceil((endTime - startTime) / 1000 / 60); // minutos
  
  const report = {
    timestamp: endTime.toISOString(),
    duration: {
      start: startTime.toISOString(),
      end: endTime.toISOString(),
      totalMinutes: duration,
      estimated: estimates.estimatedTime.total,
      efficiency: ((estimates.estimatedTime.total / duration) * 100).toFixed(2) + '%'
    },
    estimates,
    results,
    configuration: OPTIMIZATION_CONFIG,
    summary: {
      phasesExecuted: Object.keys(results).length,
      totalDocumentsProcessed: estimates.totalDocuments,
      optimizationSuccess: true
    },
    recommendations: [
      'Monitorear rendimiento de la aplicaci√≥n por 24-48 horas',
      'Verificar que todas las funcionalidades cr√≠ticas funcionan correctamente',
      'Considerar implementar √≠ndices adicionales basados en patrones de uso',
      'Planificar optimizaciones adicionales basadas en m√©tricas de rendimiento',
      'Documentar cambios realizados para futuras referencias'
    ],
    nextSteps: [
      'Ejecutar suite completa de tests',
      'Monitorear logs de aplicaci√≥n',
      'Verificar m√©tricas de rendimiento',
      'Actualizar documentaci√≥n t√©cnica',
      'Planificar pr√≥ximo ciclo de optimizaci√≥n'
    ]
  };
  
  const fs = require('fs');
  const path = require('path');
  const reportPath = path.join(__dirname, '../mongodb-optimization-final-report.json');
  
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  logger.info(`üìÑ Reporte final guardado en: ${reportPath}`);
  
  return reportPath;
}

/**
 * Funci√≥n principal de optimizaci√≥n
 */
async function optimizeMongoDB() {
  const startTime = new Date();
  
  console.log('üöÄ OPTIMIZACI√ìN COMPLETA DE MONGODB - GROW5X');
  console.log('=' .repeat(80));
  console.log(`üïê Iniciado: ${startTime.toLocaleString()}`);
  console.log('=' .repeat(80));
  
  try {
    // Verificar prerrequisitos
    const { checks, passed } = await checkPrerequisites();
    if (!passed) {
      throw new Error('Prerrequisitos no cumplidos');
    }
    
    // Estimar recursos
    const estimates = await estimateResources();
    
    // Confirmar ejecuci√≥n
    if (OPTIMIZATION_CONFIG.safety.requireConfirmation) {
      console.log('\n‚ö†Ô∏è  ADVERTENCIA: Esta operaci√≥n modificar√° la base de datos');
      console.log(`üìä Documentos a procesar: ${estimates.totalDocuments.toLocaleString()}`);
      console.log(`‚è±Ô∏è  Tiempo estimado: ${estimates.estimatedTime.total} minutos`);
      console.log(`üíæ Espacio estimado: ${estimates.estimatedSpace.total} MB`);
      console.log('\n¬øDesea continuar? (Ctrl+C para cancelar)');
      // En producci√≥n, aqu√≠ se deber√≠a pedir confirmaci√≥n del usuario
    }
    
    const results = {};
    
    // Ejecutar fases seg√∫n configuraci√≥n
    if (OPTIMIZATION_CONFIG.phases.analysis) {
      results.analysis = await executeAnalysisPhase();
    }
    
    if (OPTIMIZATION_CONFIG.phases.migration) {
      results.migration = await executeMigrationPhase();
    }
    
    if (OPTIMIZATION_CONFIG.phases.cleanup) {
      results.cleanup = await executeCleanupPhase();
    }
    
    if (OPTIMIZATION_CONFIG.phases.validation) {
      results.validation = await executeValidationPhase();
    }
    
    // Generar reporte final
    const reportPath = generateFinalReport(startTime, estimates, results);
    
    // Resumen final
    const endTime = new Date();
    const duration = Math.ceil((endTime - startTime) / 1000 / 60);
    
    console.log('\nüéâ OPTIMIZACI√ìN COMPLETADA EXITOSAMENTE');
    console.log('=' .repeat(80));
    logger.success(`‚úÖ Duraci√≥n total: ${duration} minutos`);
    logger.success(`üìä Documentos procesados: ${estimates.totalDocuments.toLocaleString()}`);
    logger.info(`üìÑ Reporte final: ${reportPath}`);
    
    console.log('\nüìã RESUMEN DE FASES:');
    Object.keys(results).forEach(phase => {
      logger.success(`‚úÖ ${phase.toUpperCase()}: Completada`);
    });
    
    console.log('\nüîÑ PR√ìXIMOS PASOS:');
    console.log('1. Monitorear aplicaci√≥n por errores');
    console.log('2. Verificar funcionalidades cr√≠ticas');
    console.log('3. Revisar m√©tricas de rendimiento');
    console.log('4. Ejecutar tests de integraci√≥n');
    console.log('5. Documentar cambios realizados');
    
  } catch (error) {
    logger.error('üí• Error durante la optimizaci√≥n:', error);
    throw error;
  } finally {
    await mongoose.disconnect();
    logger.info('üîå Desconectado de MongoDB');
  }
}

// Ejecutar optimizaci√≥n si se llama directamente
if (require.main === module) {
  optimizeMongoDB()
    .then(() => {
      console.log('\n‚ú® Proceso de optimizaci√≥n completado exitosamente');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Error fatal en optimizaci√≥n:', error);
      process.exit(1);
    });
}

module.exports = {
  optimizeMongoDB,
  checkPrerequisites,
  estimateResources,
  OPTIMIZATION_CONFIG
};